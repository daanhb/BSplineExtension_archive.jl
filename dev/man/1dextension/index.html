<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1D extension platform ¬∑ BSplineExtension.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BSplineExtension.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../basisplatform/">Basis platform</a></li><li class="current"><a class="toctext" href>1D extension platform</a><ul class="internal"><li><a class="toctext" href="#The-AZ-algorithm-1">The AZ algorithm</a></li><li><a class="toctext" href="#Sparseness-of-A-and-Z&#39;-1">Sparseness of <code>A</code> and <code>Z&#39;</code></a></li><li class="toplevel"><a class="toctext" href="#BSplineExtensionSolver-1">BSplineExtensionSolver</a></li><li><a class="toctext" href="#Column-truncation-1">Column truncation</a></li><li><a class="toctext" href="#Row-truncation-1">Row truncation</a></li><li class="toplevel"><a class="toctext" href="#B-spline-extension-approximation-1">B-spline extension approximation</a></li><li><a class="toctext" href="#Errors-1">Errors</a></li><li><a class="toctext" href="#Timings-1">Timings</a></li><li class="toplevel"><a class="toctext" href="#B-spline-extension-Reference-1">B-spline extension Reference</a></li></ul></li><li><a class="toctext" href="../ndbsplineextension/">ND extension platform</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>1D extension platform</a></li></ul><a class="edit-page" href="https://github.com/vincentcp/BSplineExtension.jl/blob/master/docs/src/man/1dextension.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>1D extension platform</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="D-B-spline-extension-1" href="#D-B-spline-extension-1">1D B-spline extension</a></h1><p>The package provides a fast solver for a B-spline extensions such as, e.g.,</p><pre><code class="language-julia-repl">julia&gt; P1 = ExtensionFramePlatform(BSplinePlatform(),0.0..0.5)
ExtensionFramePlatform(BSplinePlatform{Float64,3}(), 0.0..0.5)
julia&gt; P2 = ExtensionFramePlatform(EpsBSplinePlatform(),0.0..0.5)
ExtensionFramePlatform(EpsBSplinePlatform{Float64,3}(), 0.0..0.5)
julia&gt; P3 = ExtensionFramePlatform(CDBSplinePlatform(),0.0..0.5)
ExtensionFramePlatform(CDBSplinePlatform{Float64,3}(), 0.0..0.5)</code></pre><h2><a class="nav-anchor" id="The-AZ-algorithm-1" href="#The-AZ-algorithm-1">The AZ algorithm</a></h2><p>The AZ algorithm (reference needed) provides for a fast approximation algorithm even though the system that needs to be solved is rectangular, and highly ill conditioned</p><p>The AZ algorithm consists of three steps for solving a system <code>Ax=b</code></p><ul><li>Solve <code>(A-AZ&#39;A)x1 = (I-AZ&#39;)b</code></li><li><code>x2 = Z&#39;(b-Ax1)</code></li><li><code>x = x1 + x2</code></li></ul><p>Z can be any matrix, but the algorithm is most efficient if <code>A</code> and <code>Z&#39;</code> can be applied fast, and <code>A-AZ&#39;A</code> is of low rank.</p><p>For the platforms above these operators are readily available using <code>AZ_A</code> and <code>AZ_Zt</code>:</p><pre><code class="language-julia-repl">julia&gt; N = 200;


julia&gt; AZ_A(P1,N)
Operator D * R[1:401 ‚Üí ùïÄ] * M

R	:	Restriction of coefficients to subset
M	:	Multiplication by BasisFunctions.VerticalBandedMatrix{Float64}
D	:	Diagonal operator with element type Float64
		    ‚Ü≥ [1.0, 1.0, 1.0  ‚Ä¶  1.0, 1.0, 1.0]

julia&gt; AZ_Zt(P1,N)
Operator M‚ÇÇ * M‚ÇÅ * E[ ùïÄ ‚Üí 1:401] * D

M‚ÇÇ	:	Multiplication by Circulant{Float64,Complex{Float64}}
M‚ÇÅ	:	Multiplication by BasisFunctions.HorizontalBandedMatrix{Float64}
E	:	Extending coefficients by zero padding
D	:	Diagonal operator with element type Float64
		    ‚Ü≥ [1.0, 1.0, 1.0  ‚Ä¶  1.0, 1.0, 1.0]

julia&gt; AZ_Zt(P2,N)
Operator M‚ÇÇ * M‚ÇÅ * E[ ùïÄ ‚Üí 1:401] * D

M‚ÇÇ	:	Multiplication by BasisFunctions.HorizontalBandedMatrix{Float64}
M‚ÇÅ	:	Multiplication by BasisFunctions.HorizontalBandedMatrix{Float64}
E	:	Extending coefficients by zero padding
D	:	Diagonal operator with element type Float64
		    ‚Ü≥ [1.0, 1.0, 1.0  ‚Ä¶  1.0, 1.0, 1.0]


julia&gt; AZ_Zt(P3,N)
Operator M * E[ ùïÄ ‚Üí 1:401] * D

M	:	Multiplication by BasisFunctions.HorizontalBandedMatrix{Float64}
E	:	Extending coefficients by zero padding
D	:	Diagonal operator with element type Float64
		    ‚Ü≥ [1.0, 1.0, 1.0  ‚Ä¶  1.0, 1.0, 1.0]

</code></pre><h2><a class="nav-anchor" id="Sparseness-of-A-and-Z&#39;-1" href="#Sparseness-of-A-and-Z&#39;-1">Sparseness of <code>A</code> and <code>Z&#39;</code></a></h2><p>The <code>FrameFun</code> package contains fast solvers for solving the low-rank system of the first AZ step. However, it does not use the (œµ-)sparse (with sparse: a lot of zero elements) structure of <code>A</code> and <code>Zt</code> which is a consequence of the compact nature of a B-spline basis. For all platforms <code>AZ_A</code> returns the same operator. As is seen above <code>A</code> is a banded matrix, hence sparse. For <code>P1</code> is <code>Z&#39;</code> is the product of a banded matrix and a circulant matrix. The circulant matrix has exponentially decreasing elements in the first column, hence œµ-sparse. Only for <code>P2</code> and <code>P3</code>, <code>Z&#39;</code> is actually be sparse.</p><h1><a class="nav-anchor" id="BSplineExtensionSolver-1" href="#BSplineExtensionSolver-1">BSplineExtensionSolver</a></h1><p>The <a href="#BSplineExtension.BSplineExtensionSolver"><code>BSplineExtensionSolver</code></a> of this package uses the compactness of the B-spline basis and by consequence the sparseness of <code>A</code> and <code>Z&#39;</code>. First, the compactness of the B-spline basis introduces a lot of zero columns in <code>A-AZ&#39;A</code>. Therefore, the BSplineExtensionSolver removes the zero columns. It knows of the location of the non zero columns by using <a href="#BSplineExtension.nonzero_coefficients-Tuple{Dictionary{S,T} where T where S&lt;:Number,Real}"><code>nonzero_coefficients</code></a>. Secondly, since also the dual dictionary is (œµ-)compactness (see <a href="../basisplatform/#Basis-platforms-1">Basis platforms</a> for examples of these dual dictionaries), <code>A-AZ&#39;A</code> will contain some (œµ-)zero rows. These are also removed by the <code>BSplineExtensionSolver</code>, where <code>crop_tol</code> is a parameter that indicates how large œµ should be. The resulting system is of size <a href="#BSplineExtension.truncated_size-Tuple{BSplineExtensionSolver}"><code>truncated_size</code></a>.</p><p>Below we illustrate how the <code>truncated_size</code> of a <code>BSplineExtensionSolver</code> changes for varying platform, B-spline order (<code>m</code>), <code>crop_tol</code> and degrees of freedom (<code>N</code>).</p><h2><a class="nav-anchor" id="Column-truncation-1" href="#Column-truncation-1">Column truncation</a></h2><p>The column truncation of <code>A-AZ&#39;A</code> depends on the order of the B-spline (and the domain) only. This is seen in the figure below, which shows <code>truncated_size(S)[2]</code> with <code>S=BSplineExtensionSolver(A-A*Zt*A)</code>.</p><p><a href="../figs/truncated_size_1.pdf">[.pdf]</a>, <a href="../figs/truncated_size_1.tex">[generated .tex]</a>, <a href="../figs/truncated_size_1.tikz">[generated .tikz]</a></p><p><img src="../figs/truncated_size_1.svg" alt/></p><h2><a class="nav-anchor" id="Row-truncation-1" href="#Row-truncation-1">Row truncation</a></h2><p>The row truncation of <code>A-AZ&#39;A</code> depends on all of the parameters. This is seen in the figure below, which shows <code>truncated_size(S)[1]</code> with <code>S=BSplineExtensionSolver(A-A*Zt*A;crop_tol=crop_tol)</code> for <code>crop_tol</code> in (1e-16, 1e-10).</p><p>The truncated size reaches a limit for <code>N</code> growing large. This limit is much smaller using <code>CDBSplinePlatform</code>. The <code>EpsBSplinePlatform</code> is a bit more robust  than the <code>BSplinePlatform</code> in generating a low truncated size since it enforces the dual dictionary to be compact, while the dual dictionaries of the latter are only œµ-compact.</p><p><a href="../figs/truncated_size_2.pdf">[.pdf]</a>, <a href="../figs/truncated_size_2.tex">[generated .tex]</a>, <a href="../figs/truncated_size_2.tikz">[generated .tikz]</a></p><p><img src="../figs/truncated_size_2.svg" alt/></p><h1><a class="nav-anchor" id="B-spline-extension-approximation-1" href="#B-spline-extension-approximation-1">B-spline extension approximation</a></h1><p>The <a href="#BSplineExtension.BSplineExtensionSolver"><code>BSplineExtensionSolver</code></a> is just a means to an end. It is used in the first step of the AZ algorithm. In this section we use the solver to approximate the exponential function on the interval [0,0.5] using a B-spline basis of order <code>m</code> on the interval [0,1]. First we show the convergence results, then the time complexity of the approximation algorithm.</p><h2><a class="nav-anchor" id="Errors-1" href="#Errors-1">Errors</a></h2><p>In the figure below, which shows the uniform error of approximating a 1 dimensional analytic function (details are in the introduction of this section),  we see that convergence is algebraic (<span>$\mathcal O(N^{-m})$</span>). This is common behaviour for approximating with splines.</p><p><a href="../figs/1derrors.pdf">[.pdf]</a>, <a href="../figs/1derrors.tex">[generated .tex]</a>, <a href="../figs/1derrors.tikz">[generated .tikz]</a></p><p><img src="../figs/1derrors.svg" alt/></p><h2><a class="nav-anchor" id="Timings-1" href="#Timings-1">Timings</a></h2><p>For all platforms, the most costly part is the evaluating operator-vector multiply <span>$(A-AZ&#39;A)x$</span> since solving the system is constant in <code>N</code> (it is <span>$\mathcal O(d^3)$</span>). For the first platform the operator-vector multiply time complexity is <span>$\mathcal O(N\log N)$</span>. For the last two the multiply time complexity is <span>$\mathcal O(N)$</span>. However, the construction complexity of <code>Z&#39;</code> for the first two platforms is also <span>$\mathcal O(N\log N)$</span>.  </p><p>The quasi-linear behaviour of the method is confirmed in the figure below that show the timings for approximating a 1 dimensional analytic function     (details are in the introduction of this section).</p><p><a href="../figs/1dtimings.pdf">[.pdf]</a>, <a href="../figs/1dtimings.tex">[generated .tex]</a>, <a href="../figs/1dtimings.tikz">[generated .tikz]</a></p><p><img src="../figs/1dtimings.svg" alt/></p><h1><a class="nav-anchor" id="B-spline-extension-Reference-1" href="#B-spline-extension-Reference-1">B-spline extension Reference</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BSplineExtension.nonzero_coefficients-Tuple{Dictionary{S,T} where T where S&lt;:Number,Real}" href="#BSplineExtension.nonzero_coefficients-Tuple{Dictionary{S,T} where T where S&lt;:Number,Real}"><code>BSplineExtension.nonzero_coefficients</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">nonzero_coefficients(dict::Dictionary1d, x::Real)</code></pre><p>Return the coefficient indices (<code>UnitRange</code>) of the <code>dict</code> elements that evaluate non zero in <code>x</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/vincentcp/BSplineExtension.jl/blob/803898bb46c804164cba03d6996953943e4bbb3e/src/nonzero_cols.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BSplineExtension.BSplineExtensionSolver" href="#BSplineExtension.BSplineExtensionSolver"><code>BSplineExtension.BSplineExtensionSolver</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct BSplineExtensionSolver{T} &lt;: FrameFun.BasisFunctions.VectorizingSolverOperator{T}</code></pre><p>This solver is efficient and effective in the first step of the AZ algorithm of a compact dictionary only. For this dictionary the function <code>nonzero_coefficients</code> should be much smaller than the length of the dictionary.</p><p>See also:  <a href="#BSplineExtension.nonzero_coefficients-Tuple{Dictionary{S,T} where T where S&lt;:Number,Real}"><code>nonzero_coefficients</code></a></p><pre><code class="language-none">BSplineExtensionSolver(M::DictionaryOperator; directsolver=:qr, crop=false, crop_tol=0, verbose=false; options...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>M</code>: The operator to be solved. Its source should be an <code>ExtensionFrame</code>   (with a <code>support</code> and a <code>superdict</code>) and   its destination a GridBasis with collocation points in the source support.   The indices of the nonzero columns of <code>M</code> should be equal to the indices of the   source superdict elements that evaluate non-zero on   the source support boundary. An example is AZ&#39;A-A where A is <code>AZ_A</code> and Z&#39;   is <code>AZ_Zt</code> of the platform <code>ExtensionFramePlatform(CDBSplinePlatform(), 0.0..0.5)</code></li></ul><p><strong>Keywords</strong></p><ul><li><code>directsolver::Symbol = :qr</code>: The direct solver to use to solve the left-over   truncated Operator <code>M</code>. See <code>FrameFun</code>.</li><li><code>crop::Bool = true</code>: Truncate the nonzero rows too.</li><li><code>crop_tol::Number = 0</code>: If <code>crop</code> is true, truncate the rows with elements smaller than <code>crop_tol</code>.</li><li><code>verbose::Bool = false</code>: Print method information. See <code>FrameFun</code></li></ul><p><strong>Examples</strong></p><p>The easiest use of <code>BSplineExtensionSolver</code> is providing it just with (AZ&#39;A-A)</p><pre><code class="language-jldocs">julia&gt; P = ExtensionFramePlatform(CDBSplinePlatform(), 0.0..0.5); N = 30;

julia&gt; plunge = plungeoperator(P,N); A = AZ_A(P,N); Zt = AZ_Zt(P,N);

julia&gt; M = plunge*A;

julia&gt; S = BSplineExtensionSolver(M;crop=true)
BSplineExtensionSolver



julia&gt; b = samplingoperator(P,N)*exp;

julia&gt; x1 = S*plunge*b;

julia&gt; x2 = Zt*(b-A*x1);

julia&gt; F = DictFun(dictionary(P,N), x1 + x2)
DictFun{Float64,Float64}(A 1-dimensional Expansion with 30 degrees of freedom.
Basis: Extension frame
)</code></pre><p>More often it will be used as a parameter for <code>FrameFun</code> functionality. The following     does the same as the previous example:</p><pre><code class="language-jldocs">julia&gt; P = ExtensionFramePlatform(CDBSplinePlatform(), 0.0..0.5); N = 30;

julia&gt; Fun(exp, P, N; REG = BSplineExtensionSolver)
DictFun{Float64,Float64}(A 1-dimensional Expansion with 30 degrees of freedom.
Basis: Extension frame
)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/vincentcp/BSplineExtension.jl/blob/803898bb46c804164cba03d6996953943e4bbb3e/src/BSplineExtensionSolver.jl#L6-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BSplineExtension.truncated_size-Tuple{BSplineExtensionSolver}" href="#BSplineExtension.truncated_size-Tuple{BSplineExtensionSolver}"><code>BSplineExtension.truncated_size</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">truncated_size(op::BSplineExtensionSolver)</code></pre><p>The size of the smaller system. The one that has to be solved with a direct solver.</p></div></div><a class="source-link" target="_blank" href="https://github.com/vincentcp/BSplineExtension.jl/blob/803898bb46c804164cba03d6996953943e4bbb3e/src/BSplineExtensionSolver.jl#L126-L130">source</a></section><footer><hr/><a class="previous" href="../basisplatform/"><span class="direction">Previous</span><span class="title">Basis platform</span></a><a class="next" href="../ndbsplineextension/"><span class="direction">Next</span><span class="title">ND extension platform</span></a></footer></article></body></html>
